## 세션 하이재킹

***



### 세션 하이재킹

- 세션 가로채다



### TCP 세션 하이재킹

- 로컬 세션 하이재킹
  - TCP 시퀀스 넘버 제어의 문제점을 파고드는 공격
  - 공격 대상 탐지하면서 시퀀스 넘버를 알 수 있다.
- 원격 세션 하이재킹
  - 서버 & 클라이언트 통신에서 시퀀스 넘버를 임의로 선택하는 공격
  - 공격자는 공격 대상 탐지 불가
  - 시퀀스 넘버에 대한 정보도 거의 없음 



### 세션

- 동기화
  - 정상적인 접속을 유지한 상태
- 비동기화
  - 

### TCP 세션 동기화 과정

- 클라이언트가 자신의 시퀀스 넘버인 Client_My_Seq를 생성
- 클라이언트는 SYN 패킷에 Client_My_Seq를 서버에게 전송
- 서버는 클라이언트의 시퀀스 넘버를 보고 Server_Client_Seq를 결정
- 서버는 자신이 관리하는 자신의 시퀀스 넘버인 Server_My_Seq 생성
- 서버는 서버가 알고있는 클라이언트 시퀀스 넘버에 1을 더해서 SYN/ACK 패킷을<br> 통해 클라이언트에게 전송(서버 자신의 시퀀스 넘버와 서버가 알고있는 클라 시퀀스 넘버)
- 클라이언트는 클라가 알고있는 서버의 시퀀스 넘버를 결정함(Client_server_seq)
- 클라이언트는 클라가 알고있는 서버의 시퀀스 넘버를 ACK 패킷을 통해 서버에 전송
- 세션 성립 



### 시퀀스 넘버

- Client_My_Seq : 클라이언트 자신이 관리하는 시퀀스 넘버
- Server_Client_Seq : 서버가 알고있는 클라이언트 시퀀스 넘버
- Server_My_Seq : 서버 자신이 관리하는 시퀀스 넘버
- Client_Serevr_Seq : 클라이언트가 알고있는 서버 시퀀스 넘버 



### 크게보는 세션 하이재킹 과정

1. 클라이언트가 텔넷 서버로 접속
2. 공격자가 ARP 스푸핑으로 패킷 흐름이 자신을 통과하도록 변경
3. 공격자는 서버에게 RST 패킷을 보내 closed 상태 만듬
4. 공격자는 클라이언트의 시퀀스 넘버를 통해 서버와 세션 동기화 수행
   - 이 과정에서 서버는 공격자의 시퀀스 넘버를 통해 자신의 시퀀스 넘버를 재생성
   - 서버가 알고있는 클라이언트의 시퀀스 넘버는 공격자의 시퀀스 넘버가 됨



### 세션 하이재킹 과정

- 공격자는 스푸핑을 통해 서버, 클라이언트 패킷 둘다 확인 가능
- 공격자는 ARP 스푸핑으로 패킷 흐름이 공격자를 통과하도록 함
- 공격자는 스푸핑을 통해 서버&클라이언트가 각자 알고있는 시퀀스 넘버 조작해서 속임
  - **클라이언트는** 공격자가 생성한 **Server_Client_Seq, Server_My_Seq**를 알고있음
  - **서버는** 공격자가 생성한 **Client_My_Seq, Client_Server_Seq**를 알고있음
- 공격자는 서버에게 RST 패킷을 보내 비동기화 시킴
- 서버가 closed 상태일 때 공격자는 Client_My_Seq를 생성해서 전송
- 서버는 수신하여 Server_My_Seq결정, Server_Client_Seq+1과 Server_My_Seq를 <br> 공격자에게 전송
- 공격자는 정상 연결처럼 Client_Server_Seq 결정 후 ACK에 담아서 서버에게 보냄
- 공격자와 서버와의 세션 동기화가 이루어짐
- 서버에서는 공격자의 Client_My_Seq 전송에 대한 Server_My_Seq를 재생성 했으므로<br> 원래 클라이언트로부터 패킷이 전송되면 서버는 정상적이지 않은 시퀀스 넘버로 인식<br> 하여 ACK 패킷에 Server_My_Seq, Server_Client_Seq를 담아 보낸다.



### ACK 스톰

- TCP 세션 하이재킹 과정에서 공격자와 서버간의 세션 동기화가 이루어진 뒤 시점
- 클라이언트가 정상 패킷 전송시 서버는 비정상 시퀀스 넘버로 인식
- 서버는 ACK 패킷에 Server_My_Seq, Server_Client_Seq를 담아 보냄
  - **서버가 정상적인 시퀀스 넘버로 맞추기 위함**
-  클라이언트는 서버가 보낸 Server_Client_Seq와 자신의 Client_My_Seq가 다름을 확인
- 서버에 Client_My_Seq, Client_Server_Seq가 담긴 ACK를 보냄
- 이러한 과정이 무한히 반복 
- 클라&서버 간에 잘못된 패킷이 전달되지 않도록 ARP 스푸핑을 하면서 공격실시



### 세션 하이재킹 보안 대책

- SSH와 같이 암호화된 연결을 사용
- 비동기화 상태 탐지
  - 서버와 시퀀스 넘버를 주기적으로 탐지
- ACK 스톰 탐지
  - 윈도우 크기에 맞지 않는 데이터 전송시 윈도우 크기에 대한 교정 패킷을 보냄
  - 서로에 대한 교정 패킷이 정상적이지 않아서 무한 루프
- 패킷 유실, 재전송 증가 탐지 
  - 공격자가 중간에 끼어서 유실, 재전송 발생
- 예상치 못한 접속의 리셋



### MITM(Man In The Middle) 공격

- 중간자 공격
- 통신 상대방의 사이에 몰래 끼어드는 것
- 클라이언트와 서버간 암호화된 채널 이용시 사용
- 패킷 내용 바꾸기를 시도한다.



### SSH 

- 클라이언트가 SSH를 통해 SSH 서버에 접근, 서버의 공개키를 받음

- 클라이언트는 자신의 개인키로 데이터 암호화, 이를 서버의 공개키로 또 암호화<br> 하여 서버로 전송

- 서버는 클라의 데이터를 자신의 개인키로 복호화, 또 클라이언트의 공개키로<br> 복호화, 데이터 리딩

  

### SSH MITM

- 공격자는 ARP 스푸핑을 통해 자신이 SSH 서버인 것처럼 행세
- 클라가 공격자에게 공개키 요청, 공격자는 서버에게 공개키 요청
- 서버는 공격자에게 SSH 공개키 전송, 공격자는 공격자가 생성한 SSH 공개키 전송
- 클라는 자신의 개인키로 암호화 후, 공격자가 생성한 SSH 공개키로 또 암호화
- 클라는 암호화된 데이터를 공격자에게 전송
- 공격자는 개인키로 복호화, 클라의 공개키로 복호화 하여 데이터 확인
- 공격자는 자신의 개인키로 암호화, 리얼 서버의 공개키로 암호화 후 리얼<br> 서버에게 전송한다.



### SSL

- 클라이언트는 서버에게 지원 가능한 방식을 알려줌
- 서버는 클라에게 지원 가능 방식이 포함된 인증서를 전송
- 클라는 클라인증서를 서버에게 전송
- 암호화에 사용될 세션키를 랜덤으로 생성, 서버의 공개키로 암호화, 서버에게 전송
- 서버는 클라에게 전송받아서 자신의 개인키로 복호화, 세션키 취득
- 클라는 모든 메시지 전송 방식을 이렇게 적용할거라고 알리는 종결 메시지 전송 후 <br> 데이터 전송 단계로 이동



### SSL 스니핑

- 공격자는 임의의 인증서 생성, 클라에게 전송, 별도의 SSL 세션 생성
- 클라는 공격자에게 공개키 요청, 공격자는 서버에게 공개키 요청
- 서버는 공격자에게 SSL 공개키 전송, 공격자는 자신이 만든 공개키를 클라에게 전송
- 클라는 공격자가 만든 SSL 공개키 전송 받음
- 클라는 세션키를 랜덤으로 생성하여 공격자의 공개키로 암호화 후 공격자에게 전송
- 공격자는 자신의 개인키로 클라의 세션키를 복호화
- 공격자는 서버의 공개키로 세션키를 암호화 하고 서버에게 전송



### SSL 스트립

- 공격자는 클라와 서버간의 모든 암호화된 HTTPS 데이터를 HTTP로 변조하여 클라에게 전송
- 공격자가 서버와 클라 사이에 끼어서 클라와 공격자 간에는 HTTP 평문통신, 서버와 공격자 사이에는<br> HTTPS 암호화 통신 수행



### ipconfig /flushdns(WIndows)

- 특정 웹 사이트에 접속하기  이전 상태로 만들기 위함
-  DNS 정보 초기화 명령어



### MITM 공격 보안 대책

- 기본적 대응책은 ARP, DNS 스푸핑과 같음
- SSL MITM은 SSL 2.0 사용시 방어 가능
- 안전하지 않은 인증서 사용 금지



### SSL 스트립 공격 보안 대책

- HSTS
  - HTTP 주소를 입력해도 HTTPS를 사용하는 페이지로 자동 연결
- 본인이 접속한 사이트가 SSL로 정상 접속되고 있는지 확인



## 무선 랜

***



### 무선 랜 규격

- 802.11 : 최초의 무선 랜 프로토콜
- 802.11b : 와이파이, WEP 방식 보안(CSMA/CA)
  - CSMA : 패킷 송출전 채널이 사용중인지 아닌지를 반송파 검출에 의해 조사(말하기전에 듣기)
  - CSMA/CD : CSMA에 충돌을 검출하는 기능을 추가한 것(**유선랜 접속 프로토콜**) 
    - D는 디텍션
  - CSMA/CA : 전송 전 캐리어 감지, 일정 시간 기다림, 사전에 가능한 범위에서<br> 충돌을 회피(무선랜 다중 접속 방식)
    - A는 어보이댄스
- 802.11a : 와이파이 5, 전파 투과성, 회절성이 떨어져 단절 현상 심함, b와 호환안됌
- 802.11g : 802.11a의 속도를 802.11b에 추가한 것, 네트워크 공유시 데이터 처리 효율 떨어짐
- 802.11i : 802.11b의 표준에 보안성을 강화한 것
  - WEP이 위험해서 개발된 전송 규격임
- 802.11n : 여러 안테나를 사용, 다중 입출력 기술, 대역폭 손실 최소화
- 802.11ac : 5GHZ 주파수에서 높은 대역폭 지원, 11n과의 호환성을 위해 40MHz까지 대역포 지원



### 무선 랜 접속

- 무선 랜 공유기는 정기적으로 SSID를 브로드캐스팅 한다.



### WEP

- 802.11b 프로토콜에서부터 적용
- RC 4 암호화 알고리즘 기본
- 암호화 과정에서 IV를 사용, 공격자가 IV만 취득하면 해킹 가능
- 생일 공격 가능
- RC 4는 취약한것으로 밝혀짐
- 클라가 AP에 인증 요청
- AP는 인증용 문자열을 클라에게 전송
- 클라는 인증용 문자열을 암호화 후 AP에게 전송
- AP는 암호화된 문자열 확인 후 성공, 실패 여부 통보



### WPA

- TKIP 암호화 방식 사용
  - WEP의 취약점 해결을 위한 표준
  - 공유 개인키를 동적으로 생성, 무선 구간 패킷을 암호화



### WPA2

- CCMP 암호화 방식 사용
  - AES 블록 암호 방식을 사용
  - 높은 보안성
- EAP 인증 방식 

### WPA3

- 같은 네트워크에 연결된 기기 끼리의 데이터 액세스가 어려움
- IEEE에서 나온 최신 암호화 규격



### AP에 대한 보안 대책

- 물리적 보안 대책
  - 전파가 건물 내부로 한정되도록 출력 조정
  - 눈에 띄지 않는 곳에 설치
  - AP 기본 계정의 패스워드 재설정(초기 0000)
- 기술적 보안 대책
  - AP 암호관련 설정
  - DHCP 중지, 허용된 사용자에 한해 네트워크 IP 주소를 알려준다(수동)
  - MAC 필터링, AP에 접근 가능한 MAC 주소를 기록
- 관리적 보안 대책
  - AP 관리대장 작성
  - 인적 보안 교육
- 법적 보안 대책
  - 보안 서비스 운영 기관에서 보안 위반 행위 교육 및 공지



### 무선 랜 인증 방식

- PSK
  - 미리 설정된 공유키를 사용자, AP 간에 공유
  - 인증 서버 필요 없음
  - 확장성 없음
- EAP
  - 중앙 집중화된 관리 제공
  - 클라이언트와 RADIUS 서버 사이에 통신을 가능하게 하는 프로토콜



### 중간 정리

- 무선 랜 암호화 방식
  - WEP
  - WPA, WPA2, WPA3
- 무선 랜 인증 방식
  - EAP
  - PSK



### EAP 프로토콜 인증 방식

- 클라에서 AP에 접속 요청
- AP는 클라가 로그인할 때까지 접속 차단
- AP는 RADIUS 서버에 클라의 접속 요청 전송
- RADIUS 서버는 AP에게 인증 첼린지 전송
- AP는 클라에게 인증 첼린지 전송
- 클라는 ID, PASSWORD의 해시값을 AP에게 전송
- AP는 RADIUS 서버에 클라의 해시값 전송
- RADIUS 서버는 전송된 해시값을 사용자 관리 DB 정보에서 확인
- RADIUS 서버는 해시값이 일치하면 암호화 키 생성
- RADIUS 서버는 생성한 암호화 키를 AP에게 전달, AP는 클라에게 전송
- 클라는 전달받은 암호화 키를 이용하여 AP와 암호화 통신 수행



### 무선 랜 보안 취약점

- 물리적 보안 취약점
  - 부시고, 초기화하고, 전원 차단하고
- 기술적 보안 취약점
  - 도청
  - 서비스 거부
  - 불법 AP : 불법 AP 설치 후 사용자 정보 수집



### 규격 설정 권장

- 표준 규격 : WEP -> WPA-1 -> WPA-2
- 암호화 : TKIP -> CCMP
- 인증 : PSK -> EAP 



## DoS와 DDoS 공격

***



### DoS 공격

- 공격 대상이 수용 가능한 능력 이상의 정보를 제공
- 네트워크 용량을 초과시켜 정상적으로 작동하지 못하게 하는 공격
- 디스크, 데이터를 파괴 하거나 cpu, 메모리 등의 자원 고갈을 공격



### DoS 공격 종류(시스템 자원 고갈)

- Ping of Death

  - Ping을 사용, ICMP 패킷의 크기를 정상 보다 아주 크게 만듬
  - 네트워크를 통해 라우팅되어 대상에 도달하는 동안 작게 쪼개짐
  - 피해자는 조각화된 패킷을 모두 처리해야 하므로 정상 ping보다 <br> 부하가 심해짐
  - **보안 대책**
    - 반복적, 일정 수 이상, ICMP 패킷 -> 무시하거나 차단
    - 운영체제 보안 패치

- Syn Flooding

  - 서버별로 한정되어 있는 접속 공간에 존재하지 않는 클라이언트가<br> 접속한 것처럼 속여 다른 사용자의 서비스를 불가하게 함
  - 공격자는 많은 수의 syn 패킷을 전송
  - 서버는 syn에 대한 syn/ack를 보냄
  - 공격자 측에서 syn/ack에 대한 ack를 보내지 않고 대기하게 됨
  - 서버는 세션 연결을 계속 기다리게 된다(백로그에 빠졌다)
  - **보안 대책**
    - 침입 탐지 시스템(IDS), 침입 차단 시스템(IPS) 설치
    - 짧은 시간 안에 같은 형태의 패킷을 보내는 공격 인지시<br> 송신자 IP를 차단

- Boink, Bonk, Teardrop

  - 시스템의 패킷 재전송, 재조합에 과부하가 걸리게 함
  - Boink : 처음에는 정상 시퀀스 넘버를 보내다가 중간에서 일정한 시퀀스 넘버를 보냄
  - Bonk : 모든 패킷의 시퀀스 넘버를 처음 보낸 패킷의 시퀀스 넘버로 조작하여 모냄
  - Teardrop : 시퀀스 넘버를 일정하게 바꿈 + 중첩, 빈 공간을 만들어 시퀀스 넘버를<br> 좀 더 복잡하게 섞는다.

- Land

  - 시스템을 나쁜 상태에 빠지게 하는 것
  - 패킷을 출발지 IP, 도착지 IP를 똑같이 만들어서 공격 대상에게 전송
  - 동시 접속 사용자 수 증가, CPU 부하 가중
  - **보안 대책**
    - 라우터, 방화벽에서 출발지 IP, 도착지 IP 주소가 동일한 패킷 차단

- Smurf

  - 공격자가 피공격자 IP주소로 다이렉트 브로드캐스트를 보내서 ICMP Reply를<br> 보내면, 피공격자는 Ping of Death와 같은 공격을 받게 된다.
  - **보안 대책**
    - 라우터에서 다이렉트 브로드캐스트 차단하도록 설정

- Fraggle

  - smurf와 비슷하지만 UDP를 사용한다는 차이

  - 공격자는 브로드캐스트 주소로 포트 7을 이용해 가짜 UDP 패킷 전송

  - 네트워크  내 각 시스템은 엄청난 트래픽 생성, 공격 대상 서버로 응답

    



### DoS 공격 종류(네트워크 자원 고갈)

- HTTP Get Flooding
  - 처음에는 TCP 3 Way 핸드쉐이킹으로 정상 접속
  - HTTP Get Method를 통해 특정 페이지를 무한대로 요청
- HTTP CC Attack
  - Cache-Control 에 no-store, must-revalidate 옵션 사용하여<br> 캐싱 서버가 아닌 실제 서버에 응답하게 함
- Dynamic HTTP Request Flooding
  - 요청 페이지를 변경하여 웹 페이지를 지속적으로 요청
- Slow HTTP Header DoS(Slowloris)
  - HTTP 메시지 헤더 정보를 비정상적으로 조작(헤더의 끝을 \r\d에서 \r만 보냄)
  - 웹 서버가 헤더 정보를 완전히 수신할 때 까지 연결을 유지하도록 하여<br> 시스템 자원 소비, 다른 클라이언트의 정상적 서비스 방해
  - 웹 서버는 클라의 요청이 끝나지 않은 것으로 간주하고 로그 기록 안함
- Slow HTTP Post (RUDY)
  - 웹 서버와의 연결을 최대한 장시간 동안 유지, 웹 서버가 정상 이용자의<br> 접속을 받을 수 없는 상태를 만듬
- Mail Bomb
  - 메일 서버는 각 사용자에게 일정 디스크 공간 할당
  - 메일 폭주로 디스크 공간을 가득 채우는 것



### DDoS 공격

- 공격자 위치, 구체적원인 파악이 어려움
- 구성으로는 공격자, 마스터, 에이전트가 있음
  - 공격자 : 공격 주도 컴퓨터
  - 마스터 : 공격자에게 명령 받는 시스템, 여러 대의 에이전트 관리
  - 에이전트 : 공격 대상에 직접 공격을 가하는 시스템



### DDoS 공격 종류

- 트리누
  - UDP를 기본으로 공격 시행
  - statd, cmsd, ttdbserverd 데몬이 주 공격 대상
- TFN
  - 트리누 발전 형태
  - statd, cmsd, ttdbserverd 데몬이 주 공격 대상
  - 마스터-데몬 간에 ICMP Echo Request 패킷 사용
  - TCP, UDP 연결 이루어지지 않음
  - 공격자-마스터 간에 평문 통신 약점 존재
- TFN 2K
  - TFN 의 발전 형태
  - 통신에 특정 포트를 사용하지 않고 암호화 되어있음
  - TCP Syn Flooding, UDP Flooding, ICMP Flooding, Smurf 공격 사용
  - TCP 패킷의 헤더 길이는 항상 0
- 슈타첼드라트
  - 독일어로 철조망이라는 뜻
  - 공격자, 마스터, 에이전트, 데몬과의 통신에 암호화 기능 추가
  - TFN 발전 형태
  - 각 마스터가 제어 가능한 데몬 개수는 기본 1000개
  - 마스터에 에이전트가 자동으로 갱신된다.





### DoS, DDoS 공격 대응책

- 침입 차단 시스템(IPS)
- 시스템 패치
- 서비스별 대역폭 제한





### 침입 차단 시스템(IPS)

- 네트워크에 침입하여 들어오는 공격 탐지, 능동적 대응을 위한 시스템
- 새로운 패턴을 인식할 수 있도록 지속적 업그레이드 필요



### 시스템 패치

- 바이러스, 해킹에 취약점에 대해 각 업체에서 패치를 발표, 이를 설치
- 해당 패치가 어떤 작용을 하는지 이해한 뒤 설치 해야 함
- 백업 필수



### 서비스별 대역폭 제한

- 각 서비스별로 대역폭 조절
- 특정 서비스 외에 나머지 서비스에 영향을 최소화 할 수 있음



## 방화벽

***



### 방화벽이란?

- 네트워크 보안을 높이는데 필요한 기본적 솔루션
- 신뢰하지 않는 외부의 무차별적인 공격으로부터 내부를 보호
- 기능
  - 접근 제어
    - 통과시킬 접근, 차단할 접근을 실행
    - 패킷 필터링 방식, 프록시 방식으로 나뉨
  - 로깅과 감사 추적
    - 로깅 : 방화벽을 통과하는 패킷 및 연결에 대한 정보, 관리자 설정 변경 정보 저장
    - 감사 추적 : 시스템 내 저장된 로그를 이용해 허용되지 않은 접근 시도, 연결을 확인
  - 인증
    - 메시지 인증 : 전송되는 메시지에 대한 신뢰성 보장
    - 사용자 인증 : 패스워드, OTP 등의 인증 제공
    - 클라이언트 인증 : 특수한 접속을 요구하는 호스트가 정당한 호스트인지 확인
  - 데이터 암호화
    - 방화벽에서 다른 방화벽 까지 전송되는 데이터를 암호화
    - 보통 VPN 기능 이용



### 방화벽의 한계

- 바이러스 차단 불가
  - 패킷의 페이로드를 검사하지 않기 때문
- 내부 공격 차단 불가
- 자신을 통하지 않은 통신에 대한 제어 불가
- 새로운 형태의 공격 차단 불가
  - 명시된 규칙에 의해 방어하기 때문



### 방화벽 구조

- 베스천 호스트
- 스크리닝 라우터
- 단일 홈 게이트웨이
- 이중 홈 게이트웨이
- 스크린된 호스트 게이트웨이
- 스크린된 서브넷 게이트웨이



### 베스천 호스트

- 성곽의 모서리 둥근 부분
- 방어 정책이 구현되어 있는 네트워크에서 외부 접속에 대한 1차적인<br> 연결을 받아들이는 시스템
- 베스천 호스트 중 한 곳에 방화벽이 놓인다.



### 스크리닝 라우터

- IP주소, 포트에 대한 접근 제어만 가능
- 저렴하지만 세부적인 규칙을 적용하기 어렵다.



### 단일 홈 게이트웨이

- 스크리닝 라우터 발전 형태
- 베스천 호스트라 부르기도 함
- 방화벽의 가장 기본이 되는 기능을 수행
  - 접근 제어, 인증, 로깅 및 감사추적, 데이터 암호화
- **강한 보안 정책 실행이 가능하지만 손상되면 무조건 적인 접속 허용**



### 이중 홈 게이트웨이

- 네트워크 카드를 2개 이상 갖춘 방화벽
- 외부 네트워크, 내부 네트워크에 대한 네트워크 카드를 구분하여 운영
- 효율적 트래픽 관리 가능



### 스크린된 호스트 게이트웨이

- 라우터와 방화벽을 구분하여 운영
- 스크리닝 라우터 + 단일/이중 홈 게이트웨이 조합
- 해커가 스크리닝 라우터를 해킹하면 베스천 호스트를 거치지 않고<br> 내부 네트워크에 직접 접근 가능



### 스크린된 서브넷 게이트웨이

- 외부, 내부 네트워크 사이에 DMZ를 두는 것
- 다른 방화벽의 장점을 모두 갖춤
- 설치, 관리가 어렵고 서비스 속도가 느림
- 이중 홈 게이트웨이를 사용하면 단일 홈게이트웨이를 사용하는 것 보다<br> 속도가 빠름, 더 강력한 보안정책 사용 가능



### 보안 기본 원칙

- 페일 세이프
  - 오류 발생으로 시스템 마비시 사용자, 다른 시스템에 피해를 입히지 않아야 함
  - ex) 방화벽
- 세이프 페일루어
  - 실패가 일어난 경우에도 안전해야 함
  - 시스템 오류 발생해도 마비되지 않고 작동해야 함



### NAT

- 사용 가능한 공인 주소의 수가 인터넷에 연결되는 시스템 수에 비해 모자라는<br> 문제를 해결하기 위한 기술 
- 시스템은 내부 네트워크에서 사설 주소를 소유하고 있다가 외부로 접근할 때<br> 라우팅 가능한 외부 공인 주소를 NAT 규칙에 따라 할당받아야 접속 가능



### Normal NAT

- 내부의 사설 IP주소를 가진 클라가 외부로 접속할 때 사용하는 것
- 내부 클라가 자신의 IP와 외부서버 IP를 가지고 외부 서버에 접속 요청
- 방화벽에서는 내부 클라 IP와 외부로 나갈 수 있는 방화벽 IP를 규칙에 따라<br> 적용 시켜서 출발지 ip를 방화벽 IP로 바꾸고 외부 서버에 접속 요청
- 외부 서버에서는 처리 하고 다시 보낼 때 목적지 ip와 출발지 ip를 가지고 있는데<br> 이 때 목적지 IP는 요청을 보낸 방화벽 IP가 된다.
- 방화벽에서는 목적지 IP를 확인하여 목적지 IP와 매칭되는 내부 클라이언트의<br> IP를 목적지 IP주소로 하여 외부 서버의 응답을 전송한다.



## 암호

***



### 암호

- 스키테일 암호
  - 육각형 나무, 양피지 리본
  - 전치법 알고리즘 : 단순히 메시지에 있는 문자의 위치를 바꾸는 방법
- 시저 암호
  - 단일 치환 알고리즘 : 알파벳 한 글자를 다른 한 글자로 대체
- 모노 알파베틱 암호
  - 알파벳 26글자를 각 다른 알파벳에 1:1로 대응 시키는 방식
  - 단일 치환 암호 + 보안성 강화
- 비즈네르 암호
  - 다중 치환 알고리즘 : 암호화 키, 매핑 규칙에 따라 한 글자가 여러 글자로 대체됨



### 대칭 암호

- 암호화 키와 복호화 키가 같은 암호화 방식
- 키 배포 문제 생김, 별도의 키교환이 필요하기 때문
- 데이터 암호화가 목적
- **DES**
  - 56bit 키를 사용
  - 총 16라운드 수행
- **3DES**
  - DES를 연속으로 3번 실행
  - 2번의 암호화 1번의 복호화
  - 각 DES에서 사용하는 키가 다르다.
- **AES**
  - 128, 192, 256bit 키를 사용
  - 10, 12, 14번의 라운드 수행
- **SEED**
  - 블록 암호 알고리즘
  - 128, 256bit 키를 사용
- **ARIA**
  - 128, 192, 256bit 키를 사용



### 대칭 암호 - 블록 암호 모드

- 기존 대칭 암호화 방식에서 하나의 평문을 블록 단위로 나눠서 암호화, 복호화 수행
- 300 bit 평문을 AES로 암호화 하는 경우
  - AES 블록 크기 : 128bit
  - 블록 개수 : 3개, 128bit, 128bit, 44bit
  - 마지막 3번째 블록에 패딩
- 종류
  - **ECB 모드**
    - 각 평문 블록 단위로 암호화한 것이 그대로 암호문 블록이 되는 방식
    - 암호화, 복호화 병렬 처리 가능
  - **CBC 모드**
    - 암호문 블록을 체인처럼 연결
    - 현재 평문 블록, 현재 블록 직전에 암호화된 블록을 XOR 후 암호화
    - 처음 블록은 초기화 벡터를 사용하여 XOR 후 암호화
    - 암호화는 병렬 처리 불가, 복호화는 병렬화 가능



### 비대칭 암호 방식

- 대칭 암호에서 키 배포 문제를 해결
- 개인키, 공개키를 생성하여 공개키는 배포, 개인키는 자신이 가지고 있음
- **디피 헬만 키 교환**
  - 소수를 이용한 나머지 연산 사용
- 키 교환이 목적
- 공개키 중간자 공격에 취약
- **RSA**
  - 암호화, 전자서명 등 다양한 기능 제공
  - 공개키, 개인키 사용
  - 키 길이는 1024비트
- **공개키 암호화, 개인키 복호화(기밀성)**
  - 상대방 공개키로 암호화, 암호문 전송, 상대는 개인키로 복호화
  - 공개키를 배포한 사람이 상대방이 암호화한 것을 자신의 개인키로 복호화 하는 것 
- **개인키 암호화, 공개키 복호화(부인 방지)**
  - 자신의 개인키로 서명한 메시지를 상대에게 전송
  - 서명한 사람의 공개키를 받아와서 복호화
  - 메시지 전송자는 자신이 보낸 사실을 부인할 수 없음
- **타원 곡선 암호**
  - 키 길이는 160비트
  - 암, 복호화가 RSA보다 빠름
  - 키 크기는 작지만 높은 보안성 제공



## SSL과 TLS

***



### HTTPS

- SSL 프로토콜 위에서 동작하는 프로토콜
- 암호화된 방법으로 데이터를 전송하는 프로토콜
- HTTP에서 보안적인 약점을 보완한 것



### SSL 디지털 인증서

- 클라이언트와 서버간의 통신을 제 3자가 보증해주는 전자화된 문서
- 클라가 서버에 접속, 서버는 클라에게 인증서 정보를 전달
- 클라는 이 인증서가 신뢰할 수 있는 것인지를 검증(웹 브라우저 인증서 목록)
- 클라가 접속한 서버가 신뢰할 수 있는 서버임을 보장
- SSL 통신에 사용할 공개키를 클라이언트에게 제공



### CA

- 클라가 접속한 서버가 신뢰할 수 있는 서버인지를 보장하는 것이 인증서
- 이를 제3자가 보증해주는 제 3자는 민간기업들인 CA
- 신뢰성이 엄격히 공인된 기업들만 참여 가능

### SSL 인증서 메커니즘

- 웹 서버는 자신의 공개키와 함께 인증서를 CA에 돈주고 발급 받음
- CA에서는 해당 인증서를 자신의 개인키로 암호화 후 웹 서버에 배포
  - **공개키 방식에서 비밀키로 암호화한 정보를 공개키로 풀 수 있다는 것은?**
    - 그 정보가 공개키로 복호화한 정보가 틀림없이 공개키의 쌍으로 존재하는<br> 개인키를 가지고 있는 사람에 의해 암호화된 것이라는 것을 확인할 수 있다.
    - 정보의 출처를 신뢰할 수 있다는 것
- 웹 브가 서버에 접속할 때 웹서버로부터 인증서를 제공받음
- 브라우저는 이 인증서를 발급한 CA가 자신이 내장한 CA 리스트에 있는지 확인
- 확인결과 맞다면 해당 CA의 공개키를 이용해서 인증서를 복호화한다.



### SSL 동작 방법

- 실제 데이터 암호화 방식 : 대칭키 방식
- 대칭키의 키(대칭키 방식으로 암호화됨) 암호화 : 공개키 방식
- **악수 - 전송 - 세션 종료**
- **악수 단계**
  - 이 때 SSL 인증서를 주고 받는다.
  - 클라에서 서버에 접속할 때 클라에서 생성한 랜덤 데이터, 클라가 지원하는<br> 암호화 방식 등을 전송
  - 서버에서 클라에 대한 응답으로 서버에서 생성한 랜덤 데이터, 서버가 선택한<br> 암호화 방식, 인증서를 전송
    - 이 인증서에는 서버의 공개키가 포함
  - 클라는 서버의 랜덤 데이터, 자기 랜덤 데이터를 조합해서 프리 마스터 시크릿<br> 이라는 키를 생성, 이 값은 절대 노출되어서는 안됌
  - 클라는 서버의 인증서가 CA에 의해 발급된 것인지를 확인하기 위해<br> 브라우저에 내장된 CA 리스트를 보고 확인, CA 리스트에 있다면<br> CA의 공개키를 이용해서 인증서 복호화, 성공시 CA의 개인키로 암호화된<br> 문서임이 암시적으로 보증됨
  - 클라는 인증서 안에 있던 서버 **공개키로** 프리 마스터 시크릿 값을 암호화, 서버로 전송
  - 서버는 자신의 개인키로 복호화, 프리 마스터 시크릿 값을 서로 공유중인 것임
  - 서버와 클라는 일련의 과정을 거쳐 프리 마스터 시크릿 값을 마스터 시크릿 값으로 만들고, <br> 마스터 시크릿 값은 세션 키를 생성하는데, 이 세션키 값을 이용해서 서버와 클라는 <br> 서로 데이터를 대칭키 방식으로 암호화 한 후 주고 받는다.
  - 클라와 서버는 악수 단계 종료를 서로에게 알림
- **전송 단계(세션 단계)**
  - 실제로 서버&클라가 실제로 데이터를 주고 받는 단계
  - 상대방에게 정보를 전송하기 전에 세션 키 값을 이용해서 대칭키 방식으로 암호화 후 전송
    - 세션 키는 악수 단계에서 프리 마스터 시크릿 값의 복호화를 통해 마스터 시크릿 값으로부터<br> 나온 키 값이다.
  - 상대방도 세션 키 값을 알고있기 때문에 복호화 가능
- **세션 종료 단계**
  - 데이터 전송이 끝나면 SSL 통신이 끝났음을 서로에게 알려준다.
  - 통신에서 사용한 대칭키인 세션 키를 폐기

### SSL과 TLS

- HTTPS 프로토콜 통신에서 통신 내용을 암호화해 주는 프로토콜
- TLS는 SSL 3.0의 업그레이드 버전
- HTTP 프로토콜에서 통신을 하고 있었어도 중요 내용을 웹 서버에 전송해야<br> 되는 내용은 HTTPS로 자동으로 변경되어 통신 내용이 암호화되어 전송됌
- 전송측 레이어는 **웹 브라우저-HTTP-SSL/TLS(암호화)**
- 수신 측 레이어는 **SSL/TLS(복호화) - HTTP - 웹 서버**



### SSL/TLS 역할(기무인)

- 기밀성
  - 송수신 데이터를 도청없이 전송
  - 대칭 암호 사용
  - 대칭키를 의사난수 생성기로 만들어 디피 헬만 방식으로 키 교환
- 무결성
  - 송수신 데이터를 중간에서 조작없이 전송
- 인증
  - 상대 웹 서버가 진짜 웹 서버인지 확인
  - 일방향 해시 함수로 메시지 인증 코드 생성
  - 공개키에 디지털 서명을 붙인 인증서 사용



### SSL/TLS - 암호 스위트

- SSL/TLS에서 사용하는 대칭 암호, 공개키 교환, 디지털 서명, 일방향 해시 함수 등은<br> 부품과 같이 교환 가능
- 암호 기술의 추천 세트를 암호 스위트라 함



### openSSL

- HeartBleed 취약점
- 하트 비트 확장 기능에 요구 데이터 사이즈 체크가 결어